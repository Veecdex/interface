<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Audio Call Mini â€” Firebase + WebRTC</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style> body { background:#0f172a; color:#e6eef8 }</style>
</head>
<body class="min-h-screen flex items-center justify-center p-6">
  <div class="w-full max-w-4xl bg-slate-800 rounded-xl p-6 shadow-xl">
    <!-- Auth UI -->
    <div id="authUI" class="space-y-4">
      <h1 class="text-2xl font-bold">Realtime Audio Calls</h1>
      <div class="grid md:grid-cols-2 gap-4">
        <div class="p-4 bg-slate-700 rounded">
          <h2 class="font-semibold mb-2">Sign up</h2>
          <input id="suEmail" placeholder="Email" class="w-full p-2 rounded text-black mb-2" />
          <input id="suPassword" placeholder="Password" type="password" class="w-full p-2 rounded text-black mb-2" />
          <button id="signupBtn" class="w-full bg-green-500 p-2 rounded">Sign Up</button>
        </div>
        <div class="p-4 bg-slate-700 rounded">
          <h2 class="font-semibold mb-2">Log in</h2>
          <input id="liEmail" placeholder="Email" class="w-full p-2 rounded text-black mb-2" />
          <input id="liPassword" placeholder="Password" type="password" class="w-full p-2 rounded text-black mb-2" />
          <button id="loginBtn" class="w-full bg-blue-500 p-2 rounded">Log In</button>
        </div>
      </div>
      <div id="debug" class="text-xs text-slate-400 mt-2"></div>
    </div>

    <!-- Dashboard -->
    <div id="dashboard" class="hidden">
      <div class="flex justify-between items-center mb-4">
        <div>
          <h2 class="text-xl font-bold" id="meEmail">Hello</h2>
          <p id="meStatus" class="text-sm text-slate-400">Status</p>
        </div>
        <div class="space-x-2">
          <button id="logoutBtn" class="bg-red-500 px-3 py-1 rounded">Logout</button>
          <button id="hangupBtn" class="bg-yellow-500 px-3 py-1 rounded hidden">Hang Up</button>
        </div>
      </div>

      <div class="grid md:grid-cols-2 gap-4">
        <div class="bg-slate-700 p-4 rounded">
          <h3 class="font-semibold mb-2">Users (click Call)</h3>
          <ul id="usersList" class="space-y-2 max-h-[320px] overflow-auto"></ul>
        </div>

        <div class="bg-slate-700 p-4 rounded">
          <h3 class="font-semibold mb-2">Call</h3>
          <div id="callInfo" class="min-h-[150px] flex flex-col items-center justify-center text-center">
            <p id="callState" class="text-slate-300">No call</p>
            <audio id="localAudio" autoplay muted></audio>
            <audio id="remoteAudio" autoplay></audio>
          </div>
        </div>
      </div>
    </div>

    <!-- Incoming modal -->
    <div id="incomingModal" class="hidden fixed inset-0 flex items-center justify-center z-50">
      <div class="bg-slate-900 p-6 rounded-xl shadow-2xl border border-slate-600">
        <h3 class="text-lg font-bold mb-2">Incoming call</h3>
        <p id="incomingFrom" class="mb-4"></p>
        <div class="flex gap-2">
          <button id="acceptBtn" class="bg-green-500 px-3 py-1 rounded">Accept</button>
          <button id="rejectBtn" class="bg-red-500 px-3 py-1 rounded">Reject</button>
        </div>
      </div>
    </div>

    <p class="mt-4 text-xs text-slate-400">Replace firebaseConfig below. Use HTTPS or localhost. Open two tabs to test.</p>
  </div>

  <script type="module">
const firebaseConfig = {
    apiKey: "AIzaSyCJs6dtU8pWGk3QJ5VwKWcJIBMkSx8cjtA",
    authDomain: "caststream-fe559.firebaseapp.com",
    projectId: "caststream-fe559",
    storageBucket: "caststream-fe559.firebasestorage.app",
    messagingSenderId: "956968728492",
    appId: "1:956968728492:web:97413f75a5e7d0a69bac09",
    measurementId: "G-0WN3GFEVP6"
  };
    // ----------------------------

    // --- Imports ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
    import {
      getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut
    } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
    import {
      getFirestore, collection, doc, setDoc, onSnapshot, addDoc, getDoc, updateDoc,
      serverTimestamp, query, where
    } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // UI refs
    const authUI = document.getElementById('authUI');
    const dashboard = document.getElementById('dashboard');
    const usersList = document.getElementById('usersList');
    const meEmail = document.getElementById('meEmail');
    const meStatus = document.getElementById('meStatus');
    const callState = document.getElementById('callState');
    const localAudio = document.getElementById('localAudio');
    const remoteAudio = document.getElementById('remoteAudio');
    const incomingModal = document.getElementById('incomingModal');
    const incomingFrom = document.getElementById('incomingFrom');
    const acceptBtn = document.getElementById('acceptBtn');
    const rejectBtn = document.getElementById('rejectBtn');
    const hangupBtn = document.getElementById('hangupBtn');
    const debugEl = document.getElementById('debug');
    const signupBtn = document.getElementById('signupBtn');
    const loginBtn = document.getElementById('loginBtn');
    const logoutBtn = document.getElementById('logoutBtn');

    // WebRTC state
    let pc = null;
    let localStream = null;
    let currentCallDocRef = null;
    let usersUnsub = null;
    let incomingUnsub = null;
    let candidatesUnsub = null;

    // TURN + STUN config
    const rtcConfig = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "turn:relay.metered.ca:80", username: "openai", credential: "openai" },
        { urls: "turn:relay.metered.ca:443", username: "openai", credential: "openai" }
      ]
    };

    function logDebug(msg) {
      console.log(msg);
      debugEl.textContent = String(msg);
    }

    // prepare mic once after login/signup
    async function prepareMedia() {
      try {
        if (!localStream) {
          localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          localAudio.srcObject = localStream;
          console.log("Microphone ready");
        }
      } catch (e) {
        alert("Microphone access required: " + e.message);
        throw e;
      }
    }

    // presence
    async function setPresence(uid, email, online) {
      await setDoc(doc(db, 'users', uid), { uid, email, online, updatedAt: serverTimestamp() }, { merge: true });
    }

    // hangup
    async function hangUp() {
      logDebug("Hanging up");
      try { if (pc) { pc.getSenders().forEach(s => s.track && s.track.stop()); pc.close(); pc = null; } } catch {}
      if (currentCallDocRef) { await updateDoc(currentCallDocRef, { status: 'ended' }); currentCallDocRef = null; }
      if (candidatesUnsub) { candidatesUnsub(); candidatesUnsub=null; }
      remoteAudio.srcObject = null; callState.textContent = "No call";
      hangupBtn.classList.add("hidden");
    }
    hangupBtn.onclick = hangUp;

    // signup/login
    signupBtn.onclick = async () => {
      const email = document.getElementById('suEmail').value.trim();
      const pw = document.getElementById('suPassword').value;
      await createUserWithEmailAndPassword(auth, email, pw);
    };
    loginBtn.onclick = async () => {
      const email = document.getElementById('liEmail').value.trim();
      const pw = document.getElementById('liPassword').value;
      await signInWithEmailAndPassword(auth, email, pw);
    };
    logoutBtn.onclick = () => signOut(auth);

    // auth state
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        authUI.classList.add("hidden"); dashboard.classList.remove("hidden");
        meEmail.textContent = user.email;
        await setPresence(user.uid, user.email, true);
        await prepareMedia(); // ðŸ”‘ mic ready immediately
        // list users
        usersUnsub = onSnapshot(collection(db,'users'), (snap) => {
          usersList.innerHTML=""; snap.forEach(d => {
            const u = d.data(); if (!u) return;
            const li=document.createElement("li");
            li.className="flex justify-between items-center bg-slate-800 p-2 rounded";
            li.innerHTML=`<div><div>${u.email}</div><div class="text-xs">${u.online?'online':'offline'}</div></div>`;
            if (u.uid!==user.uid) {
              const btn=document.createElement("button"); btn.className="bg-blue-600 px-2 py-1 rounded"; btn.textContent="Call";
              btn.onclick=()=>startCallAsCaller(u.uid,u.email); li.appendChild(btn);
            } else { li.appendChild(document.createTextNode("You")); }
            usersList.appendChild(li);
          });
        });
        // incoming
        const incomingQ=query(collection(db,'calls'), where('to','==',user.uid), where('status','==','ringing'));
        incomingUnsub=onSnapshot(incomingQ,(snap)=>snap.docChanges().forEach(ch=>{
          if (ch.type==="added") {
            const callDoc=ch.doc, data=callDoc.data();
            incomingFrom.textContent=`From: ${data.fromEmail}`;
            incomingModal.classList.remove("hidden");
            acceptBtn.onclick=()=>{incomingModal.classList.add("hidden");handleIncomingCallAccept(callDoc.id)};
            rejectBtn.onclick=()=>updateDoc(callDoc.ref,{status:"rejected"});
          }
        }));
      } else {
        authUI.classList.remove("hidden"); dashboard.classList.add("hidden");
        if (usersUnsub) usersUnsub(); if (incomingUnsub) incomingUnsub();
      }
    });

    // caller
    async function startCallAsCaller(targetUid,targetEmail){
      const me=auth.currentUser; if(!me) return;
      callState.textContent=`Calling ${targetEmail}`; hangupBtn.classList.remove("hidden");
      pc=new RTCPeerConnection(rtcConfig);
      localStream.getTracks().forEach(t=>pc.addTrack(t,localStream));
      pc.ontrack=(e)=>{remoteAudio.srcObject=e.streams[0];callState.textContent=`In call with ${targetEmail}`};
      const callDoc=await addDoc(collection(db,'calls'),{from:me.uid,fromEmail:me.email,to:targetUid,toEmail:targetEmail,status:'ringing',createdAt:serverTimestamp()});
      currentCallDocRef=callDoc;
      const offer=await pc.createOffer(); await pc.setLocalDescription(offer);
      await updateDoc(callDoc,{offer:{type:offer.type,sdp:offer.sdp}});
      const callerCand=collection(callDoc,'callerCandidates');
      pc.onicecandidate=(e)=>{if(e.candidate)addDoc(callerCand,e.candidate.toJSON());};
      // listen for answer
      onSnapshot(callDoc,(snap)=>{const d=snap.data();if(d?.answer&&!pc.currentRemoteDescription)pc.setRemoteDescription(d.answer);if(d?.status==='rejected'){alert("Rejected");hangUp();}});
      // callee ICE
      candidatesUnsub=onSnapshot(collection(callDoc,'calleeCandidates'),(s)=>s.docChanges().forEach(ch=>{if(ch.type==='added')pc.addIceCandidate(ch.doc.data())}));
    }

    // callee
    async function handleIncomingCallAccept(callId){
      const callDoc=doc(db,'calls',callId); currentCallDocRef=callDoc;
      const snap=await getDoc(callDoc), data=snap.data();
      pc=new RTCPeerConnection(rtcConfig);
      localStream.getTracks().forEach(t=>pc.addTrack(t,localStream));
      pc.ontrack=(e)=>{remoteAudio.srcObject=e.streams[0];callState.textContent=`In call with ${data.fromEmail}`};
      await pc.setRemoteDescription(data.offer);
      const answer=await pc.createAnswer(); await pc.setLocalDescription(answer);
      await updateDoc(callDoc,{answer:{type:answer.type,sdp:answer.sdp},status:'connected'});
      const calleeCand=collection(callDoc,'calleeCandidates');
      pc.onicecandidate=(e)=>{if(e.candidate)addDoc(calleeCand,e.candidate.toJSON());};
      candidatesUnsub=onSnapshot(collection(callDoc,'callerCandidates'),(s)=>s.docChanges().forEach(ch=>{if(ch.type==='added')pc.addIceCandidate(ch.doc.data())}));
      hangupBtn.classList.remove("hidden");
    }
  </script>
</body>
</html>
